#include <iostream>#include <fstream>#include <map>#include <list>#include "../Defs.h"#include "../McpTarget.h"#include "../MultiRawTargetModules.h"#include "../MultiTargetModules.h"#include "TH1.h"#include "TFile.h"#include "TTree.h"#include "TCanvas.h"#include "TMath.h"#include "TMultiGraph.h"//holding values for a pmt pulseclass PmtPulse {public:  Double_t minAbs; //absolut value of pulse minimum  Double_t fwhm; //full width at half minimum  Double_t area; //surface area of peak  Double_t minPos; //position of minimum in ns  Int_t entry;  Int_t module;  Int_t channel;  Double_t eventTime; //time of event in ns  TGraph *pulseGraph;};//holding values for a detected muonclass Muon {public:  Int_t entry;  //module0  Double_t timeMod0; //time of muon event in module, (entry number * 512ns + minimum position)  Int_t chanMod0;   TGraph *pulseMod0;  //module1  Double_t timeMod1; //all timeMod variables similar calculated as timeMod0  Int_t chanMod1;  TGraph *pulseMod1;  //module2  Double_t timeMod2;  Int_t chanMod2;  TGraph *pulseMod2;  //module3  Double_t timeMod3;  Int_t chanMod3;  TGraph *pulseMod3;};TGraph *getBoxCar(TGraph *grWave, Int_t halfWidth);TObjArray *reduceNoise(TObjArray* channelLine);TObjArray *correctOffset(TObjArray* channelLine);PmtPulse *peakAnalysis(TGraph *channel);void drawGraph(TGraph* channel, Int_t i, Int_t module, Int_t chan);Bool_t pmtCheck(PmtPulse *peak);list<Muon*> muonAnalysis(list<PmtPulse*> pulseList);void displayMuons(list<Muon*> muonList);class PmtPulse;class Muon;void muonAnalysis(char *fileName) {  McpTarget *myTarget = new McpTarget(1);  //myTarget->loadPedestal();  MultiRawTargetModules *multiRawTargetDataPtr=0;  MultiTargetModules *multiTargetDataPtr=0;  TFile *offlineFile = new TFile(fileName);  TTree *mcpTree = (TTree*) offlineFile->Get("mcpTree");  if(!mcpTree) { //checks if a tree exists    std::cerr << "No input tree -- giving up\n";    exit(0);  }  mcpTree->SetBranchAddress("target",&multiRawTargetDataPtr);  Int_t numEntries=mcpTree->GetEntries();  std::cout << "Looping over " << numEntries << " entries.\n";  list<PmtPulse*> pulseList;    /*  //Histograms to analyse minimum distribution in individual modules  TH1D *histMod0 = new TH1D("histMod0", "Minimum Module 0",102,0,512);  TH1D *histMod1 = new TH1D("histMod1", "Minimum Module 1",102,0,512);  TH1D *histMod2 = new TH1D("histMod2", "Minimum Module 2",102,0,512);  TH1D *histMod3 = new TH1D("histMod3", "Minimum Module 3",102,0,512);  */  //initialising variables to count PMT pulses in individual modules  int pmtPulseCounter = 0; int pmtPulseCounter0 = 0; int pmtPulseCounter1 = 0; int pmtPulseCounter2 = 0; int pmtPulseCounter3 = 0;  for(int i=5;i<numEntries;i++) { //start from 5th entry because first entries contain voltage fluctuations    mcpTree->GetEntry(i);     if(i%100==0) std::cerr << "*";    if(multiTargetDataPtr) delete multiTargetDataPtr;    multiTargetDataPtr=new MultiTargetModules(multiRawTargetDataPtr);    myTarget->fillVoltageArray(multiTargetDataPtr);    const int n = multiTargetDataPtr->getChannel(0,0)->GetN(); //Number of points in TGraph    if (n!=512) std::cerr << "number of points in graph is not 512!\n";    for(int module=0;module<4;module++) {       for(int line=0;line<8;line++) { //looping over individual channel lines to reduce repeating noise in channels        TObjArray *channelLine = new TObjArray(); //creating collection of channels of this line        for(int chaninline=0;chaninline<8;chaninline++) {          TGraph *chanTemp = multiTargetDataPtr->getChannel(module,chaninline + line*8);      	  channelLine->Add(chanTemp); //adding channel to channel line collection        }        //Data preparation for whole channel line      	TObjArray *offsetCorrLine = (TObjArray*)correctOffset(channelLine); //offset correction of channelLine      	TObjArray *reducedLine = (TObjArray*)reduceNoise(offsetCorrLine); //reduction of channelLine        TGraph *channel;        TGraph *channelUnfilt;        PmtPulse *peak;        //now handling individual channels of each line      	for(int chanNo=0;chanNo<8;chanNo++) {      	  Int_t chan = (line*8 + chanNo);      	  channelUnfilt = (TGraph*)reducedLine->At(chanNo);          channel = getBoxCar(channelUnfilt,7); //Filtering high frequency noise          peak = peakAnalysis(channel); //collecting properties of graph          //Double_t minAbsVal = peak->minAbs; //only needed for histogram analysis          peak->module = module; //is needed because pmtCheck distinguishes between the modules          Bool_t peakIsPulse = pmtCheck(peak); //checking if pulse fulfill criteria to be a PMT pulse candidate          //further processing if graph contains PMT pulse candidate          if (peakIsPulse) {            pmtPulseCounter++;            peak->entry = i;            peak->channel = chan;            peak->eventTime = i*512 + peak->minPos; //entry * 512ns of each entry + position of minimum in ns            peak->pulseGraph = channel;            pulseList.push_back(peak); //adding PMT pulse object to list            //counting PMT pulses in modules and adding to histograms if needed            if(module==0) {              //histMod0->Fill(minAbsVal);              pmtPulseCounter0++;            } else if(module==1) {              //histMod1->Fill(minAbsVal);              pmtPulseCounter1++;            }else if(module==2) {              //histMod2->Fill(minAbsVal);              pmtPulseCounter2++;            }else if(module==3) {              //histMod3->Fill(minAbsVal);              pmtPulseCounter3++;            }          }      	}      	delete channelLine;        delete channel;        delete channelUnfilt;        delete peak;      }    }  }    cout << "\nTotal number of pulses: " << pmtPulseCounter << endl;  cout << "Number of pulses in mod0: " << pmtPulseCounter0 << endl;  cout << "Number of pulses in mod1: " << pmtPulseCounter1 << endl;  cout << "Number of pulses in mod2: " << pmtPulseCounter2 << endl;  cout << "Number of pulses in mod3: " << pmtPulseCounter3 << endl;  list<Muon*> muonList = muonAnalysis(pulseList); //checking for muons in data  displayMuons(muonList); //printing muon properties to screen  /*  //draw histograms for minimum analysis if needed  new TCanvas();  histMod0->Draw();  new TCanvas();  histMod1->Draw();  new TCanvas();  histMod2->Draw();  new TCanvas();  histMod3->Draw();  */}  //______________________________________________________________________________________//function to reduce the repeating noise structure in each channel lineTObjArray *reduceNoise(TObjArray* channelLine) {  TObjArray *reducedLine = new TObjArray();  TGraph *firstChan = (TGraph*)channelLine->At(0);  Double_t *x = firstChan->GetX();  const int n = firstChan->GetN();  Double_t average[512]={0}; //create array for average voltage values of channel line  for(int chanID=0; chanID<8; chanID++) { //loop over channels to create average    TGraph *chanFirst = (TGraph*)channelLine->At(chanID);    for(int point=0; point<n; point++) {       average[point]+= (chanFirst->GetY()[point])/8;    }    //delete chanFirst;  }  TGraph *avGraph = new TGraph(n,x,average);  for(int chanID=0; chanID<8; chanID++) { //loop over channels to reduce channels    TGraph *chanSecond = (TGraph*)channelLine->At(chanID);    Double_t reduced[512]={0};    for(int point=0; point<n; point++) {      reduced[point] = chanSecond->GetY()[point] - avGraph->GetY()[point];    }    delete chanSecond;    x = chanSecond->GetX();    TGraph *redChannel = new TGraph(n, x, reduced);    reducedLine->Add(redChannel);  }  return reducedLine;}//______________________________________________________________________________________//function to correct offset of each individual graphTObjArray *correctOffset(TObjArray* channelLine) {  TObjArray *correctedLine = new TObjArray();  TGraph *firstChan = (TGraph*)channelLine->At(0);  Double_t *x = firstChan->GetX();  const int n = firstChan->GetN();  for(int chanID=0; chanID<8; chanID++) { //loop over channels to correct channel offset    TGraph *channel = (TGraph*)channelLine->At(chanID);    Double_t mean = channel->GetMean(2);    Double_t corrected[512]={0};    for(int point=0; point<n; point++) {      corrected[point] = channel->GetY()[point] - mean;    }    // delete channel;    TGraph *corChannel = new TGraph(n, x, corrected);    correctedLine->Add(corChannel);  }  return correctedLine;}//______________________________________________________________________________________//method to determine characteristics of graphs and return them as a PmtPulse objectPmtPulse *peakAnalysis(TGraph* channel) {  PmtPulse *peak = new PmtPulse();  Int_t numPoints = channel->GetN();  //Minimum  Double_t mean = channel->GetMean(2);  Double_t min = mean;  Double_t *yVal = channel->GetY();  Int_t minPos = -1;  for(int i=0;i<numPoints;i++) {    if(yVal[i]<min) {      min=yVal[i];      minPos=i;    }  }  Double_t minAbs = abs(min);  peak->minAbs = minAbs;  peak->minPos = minPos;  //FWHM     Int_t fwhm = -1;  Int_t bin1 = -1;  Int_t bin2 =numPoints;     for(int i=minPos;i>0;i--) { //finding first bin    if(yVal[i]<=min/2) {      bin1 = i;      break;    }  }  for(int i=minPos; i<numPoints; i++) { //finding second bin    if(yVal[i]>=min/2 && i>minPos) {      bin2 = i;      break;    }  }  fwhm = bin2-bin1;  peak->fwhm = fwhm;  //Area  Double_t area = -1;  for(int i=minPos; i>10; i--) {    if(yVal[i]<mean) {     area += yVal[i];    } else {      break;    }  }  for(int i=minPos; i<(numPoints-10); i++) {    if(yVal[i]<mean) {      area += yVal[i];    } else {      break;    }  }  area = abs(area);	peak->area = area;  return peak;}//______________________________________________________________________________________//method to determine whether peak is PMT pulse candidate or notBool_t pmtCheck(PmtPulse *peak) {  Bool_t isPMTPulse = false;  Bool_t minTrue = false;  //getting peak values    Double_t minAbsVal = peak->minAbs;  Double_t fwhm = peak->fwhm;  //Double_t area = peak->area; //a further area criterion should be included after detector data is enhanced  Int_t module = peak->module;  //threshold values can be changed depending on the detector settings  if (module==0 && minAbsVal>20 ) {minTrue = true;}  else if (module==1 && minAbsVal>25) {minTrue = true;}  else if (module==2 && minAbsVal>25) {minTrue = true;}  else if (module==3 && minAbsVal>25) {minTrue = true;}  //defining threshold for fwhm to exclude voltage flucutation peaks  if(minTrue && fwhm<150 && fwhm>20) {isPMTPulse=true;}  return isPMTPulse;}//______________________________________________________________________________________//method to display properties of individual muonsvoid displayMuons(list<Muon*> muonList) {  Int_t muonCounter = 1;  cout << "There was a total number of " << muonList.size() << " muons detected\n";  for (list<Muon*>::iterator muonNumber=muonList.begin(), end=muonList.end(); muonNumber!=end; ++muonNumber) {    cout << "Muon number " << muonCounter << ":\n";    muonCounter++;    //collecting muon properties    Int_t entry = (*muonNumber)->entry;    //printing muon properties    cout << "Module 0 was crossed in channel " << (*muonNumber)->chanMod0 << " at t = " << (*muonNumber)->timeMod0 << "ns\n";    cout << "Module 1 was crossed in channel " << (*muonNumber)->chanMod1 << " at t = " << (*muonNumber)->timeMod1 << "ns\n";    cout << "Module 2 was crossed in channel " << (*muonNumber)->chanMod2 << " at t = " << (*muonNumber)->timeMod2 << "ns\n";    cout << "Module 3 was crossed in channel " << (*muonNumber)->chanMod3 << " at t = " << (*muonNumber)->timeMod3 << "ns\n";    //drawing muon graphs if not too many muons found    if(muonList.size()<4) {      drawGraph((*muonNumber)->pulseMod0, entry, 0, (*muonNumber)->chanMod0);      drawGraph((*muonNumber)->pulseMod1, entry, 1, (*muonNumber)->chanMod1);      drawGraph((*muonNumber)->pulseMod2, entry, 2, (*muonNumber)->chanMod2);      drawGraph((*muonNumber)->pulseMod3, entry, 3, (*muonNumber)->chanMod3);    }  }}//______________________________________________________________________________________//checks if PMT pulse occurs in all modules at same time plus travel time and position errorlist<Muon*> muonAnalysis(list<PmtPulse*> pulseList) {  list<Muon*> muonList;  Muon *muonCandidate = new Muon;  Double_t travelTimePos = 14; //time of muon to travel from one to the next module plus error in minimum position  Double_t travelTimeNeg = -7; //position error minus travel time  //loop over module 0  for (list<PmtPulse*>::iterator pulseIt0=pulseList.begin(), end0=pulseList.end(); pulseIt0!=end0; ++pulseIt0) {      if ((*pulseIt0)->module == 0) {      Double_t timeMod0 = (*pulseIt0)->eventTime;      //module 1 check      for (list<PmtPulse*>::iterator pulseIt1=pulseList.begin(), end1=pulseList.end(); pulseIt1!=end1; ++pulseIt1) {        Double_t timeMod1 = (*pulseIt1)->eventTime;        Double_t deltaTime01 = timeMod1 - timeMod0;        if ((*pulseIt1)->module == 1 && deltaTime01<=travelTimePos && deltaTime01>=travelTimeNeg) {          //module 2 check          for (list<PmtPulse*>::iterator pulseIt2=pulseList.begin(), end2=pulseList.end(); pulseIt2!=end2; ++pulseIt2) {            Double_t timeMod2 = (*pulseIt2)->eventTime;            Double_t deltaTime12 = timeMod2 - timeMod1;            if ((*pulseIt2)->module == 2 &&  deltaTime12<=travelTimePos && deltaTime12>=travelTimeNeg) {              cout << "Match in first three modules detected" << endl;              //module 3 check              for (list<PmtPulse*>::iterator pulseIt3=pulseList.begin(), end3=pulseList.end(); pulseIt3!=end3; ++pulseIt3) {                Double_t timeMod3 = (*pulseIt3)->eventTime;                Double_t deltaTime23 = timeMod3 - timeMod2;                if ((*pulseIt3)->module == 3 &&  deltaTime23<=travelTimePos && deltaTime23>=travelTimeNeg) {                  cout << "Muon detected!" << endl;                                  //adding properties of muon                  muonCandidate->entry = (*pulseIt0)->entry;                  //module 0 properties                  muonCandidate->timeMod0 = timeMod0;                  muonCandidate->chanMod0 = (*pulseIt0)->channel;                  muonCandidate->pulseMod0 = (*pulseIt0)->pulseGraph;                  //module 1 properties                  muonCandidate->timeMod1 = timeMod1;                  muonCandidate->chanMod1 = (*pulseIt1)->channel;                  muonCandidate->pulseMod1 = (*pulseIt1)->pulseGraph;                  //module 2 properties                  muonCandidate->timeMod2 = timeMod2;                  muonCandidate->chanMod2 = (*pulseIt2)->channel;                  muonCandidate->pulseMod2 = (*pulseIt2)->pulseGraph;                  //module 3 properties                  muonCandidate->timeMod3 = timeMod3;                  muonCandidate->chanMod3 = (*pulseIt3)->channel;                  muonCandidate->pulseMod3 = (*pulseIt3)->pulseGraph;                    muonList.push_back(muonCandidate); //adding muon to list                  }              }            }          }        }      }    }      }  return muonList;}//______________________________________________________________________________________//method to display graphvoid drawGraph(TGraph* channel, Int_t i, Int_t module, Int_t chan) {  new TCanvas();  char title[100];  sprintf(title, "entry = %d, module = %d, chan = %d", i, module, chan);  channel->SetTitle(title);  channel->Draw("alp");}//______________________________________________________________________________//method to filter high frequency noise (adapted from pulseFinder.C script)TGraph *getBoxCar(TGraph *grWave, Int_t halfWidth) {  //Just do this the lazy way for now  Double_t *inY = grWave->GetY();  Double_t *inX = grWave->GetX();  Int_t length=grWave->GetN();  Double_t *smoothY = new Double_t[length];  for(int i=0;i<length;i++) {    smoothY[i]=0;    if(i<halfWidth || length-i<=halfWidth) {      int countVals=0;      for(int j=i-halfWidth;j<=i+halfWidth;j++) {	if(j>=0 && j<length) {	  smoothY[i]+=inY[j];	  countVals++;	}      }      //      cout << i << "\t" << countVals << endl;      smoothY[i]/=countVals;    }    else {      for(int j=i-halfWidth;j<=i+halfWidth;j++) {	smoothY[i]+=inY[j];      }      smoothY[i]/=1+2*halfWidth;    }        }  TGraph *grSmooth = new TGraph(length,inX,smoothY);  delete [] smoothY;  return grSmooth; }